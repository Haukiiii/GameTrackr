{"ast":null,"code":"import dates from './dates';\n// assumes both are supported or none\nlet supportStyles = false;\nnew Intl.DateTimeFormat(undefined, {\n  // @ts-ignore\n  get dateStyle() {\n    supportStyles = true;\n  }\n});\nconst dateShort = {\n  day: 'numeric',\n  month: 'numeric',\n  year: 'numeric'\n};\nconst timeShort = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\nconst getFormatter = (culture, options) => Intl.DateTimeFormat(culture, options).format;\n/**\n * A `react-widgets` Localizer using native `Intl` APIs.\n *\n */\n\nclass IntlDateLocalizer {\n  constructor() {\n    let {\n      culture = undefined,\n      firstOfWeek = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.culture = culture;\n    this.firstOfWeek = () => firstOfWeek;\n    function normalizeFormat(date, format) {\n      return typeof format === 'function' ? format(date, culture) : date.toLocaleString(culture, format);\n    }\n    const formats = {\n      date: getFormatter(culture,\n      // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short'\n      } : dateShort),\n      time: getFormatter(culture,\n      // @ts-ignore\n      supportStyles ? {\n        timeStyle: 'short'\n      } : timeShort),\n      datetime: getFormatter(culture,\n      // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short',\n        timeStyle: 'short'\n      } : Object.assign({}, dateShort, timeShort)),\n      header: getFormatter(culture, {\n        month: 'short',\n        year: 'numeric'\n      }),\n      weekday: getFormatter(culture, {\n        weekday: 'narrow'\n      }),\n      dayOfMonth: getFormatter(culture, {\n        day: '2-digit'\n      }),\n      month: getFormatter(culture, {\n        month: 'short'\n      }),\n      year: getFormatter(culture, {\n        year: 'numeric'\n      }),\n      decade: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'decade'))}`,\n      century: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'century'))}`\n    };\n    Object.keys(formats).forEach(key => {\n      this[key] = (date, format) => format ? normalizeFormat(date, format) : formats[key](date);\n    });\n  }\n  toFormattedParts(date) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      dateStyle: 'short',\n      timeStyle: 'short'\n    };\n    return Intl.DateTimeFormat(this.culture, format).formatToParts(date).filter(p => p.type !== 'timeZoneName');\n  }\n  parse(value) {\n    const date = new Date(value);\n    return isNaN(+date) ? null : date;\n  }\n}\n\n/**\n * A number localization strategy based on `Intl.NumberFormat`.\n */\nclass IntlNumberLocalizer {\n  constructor() {\n    let {\n      culture = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _$toLocaleString$m;\n    this.culture = culture;\n    const decimal = 'formatToParts' in Intl.NumberFormat(culture) ? Intl.NumberFormat(culture).formatToParts(1.1)[1].value : ((_$toLocaleString$m = 1.1.toLocaleString(culture).match(/[^\\d]/)) == null ? void 0 : _$toLocaleString$m[0]) || '.';\n    const formatter = Intl.NumberFormat(culture).format;\n    this.decimalCharacter = () => decimal;\n    this.format = (num, format) => {\n      if (format) {\n        return typeof format === 'function' ? format(num, culture) : num.toLocaleString(culture, format);\n      }\n      return formatter(num);\n    };\n  }\n  parse(value) {\n    return parseFloat(value.replace(this.decimalCharacter(), '.'));\n  }\n}\nexport { IntlDateLocalizer as DateLocalizer, IntlNumberLocalizer as NumberLocalizer };","map":{"version":3,"names":["dates","supportStyles","Intl","DateTimeFormat","undefined","dateStyle","dateShort","day","month","year","timeShort","hour","minute","getFormatter","culture","options","format","IntlDateLocalizer","constructor","firstOfWeek","arguments","length","normalizeFormat","date","toLocaleString","formats","time","timeStyle","datetime","Object","assign","header","weekday","dayOfMonth","decade","endOf","century","keys","forEach","key","toFormattedParts","formatToParts","filter","p","type","parse","value","Date","isNaN","IntlNumberLocalizer","_$toLocaleString$m","decimal","NumberFormat","match","formatter","decimalCharacter","num","parseFloat","replace","DateLocalizer","NumberLocalizer"],"sources":["C:/Users/Viktor/Desktop/TDDD27/Ny mapp/Third commit/node_modules/react-widgets/esm/IntlLocalizer.js"],"sourcesContent":["import dates from './dates';\n// assumes both are supported or none\nlet supportStyles = false;\nnew Intl.DateTimeFormat(undefined, {\n  // @ts-ignore\n  get dateStyle() {\n    supportStyles = true;\n  }\n\n});\nconst dateShort = {\n  day: 'numeric',\n  month: 'numeric',\n  year: 'numeric'\n};\nconst timeShort = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\n\nconst getFormatter = (culture, options) => Intl.DateTimeFormat(culture, options).format;\n/**\n * A `react-widgets` Localizer using native `Intl` APIs.\n *\n */\n\n\nclass IntlDateLocalizer {\n  constructor({\n    culture = undefined,\n    firstOfWeek = 0\n  } = {}) {\n    this.culture = culture;\n\n    this.firstOfWeek = () => firstOfWeek;\n\n    function normalizeFormat(date, format) {\n      return typeof format === 'function' ? format(date, culture) : date.toLocaleString(culture, format);\n    }\n\n    const formats = {\n      date: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short'\n      } : dateShort),\n      time: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        timeStyle: 'short'\n      } : timeShort),\n      datetime: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short',\n        timeStyle: 'short'\n      } : Object.assign({}, dateShort, timeShort)),\n      header: getFormatter(culture, {\n        month: 'short',\n        year: 'numeric'\n      }),\n      weekday: getFormatter(culture, {\n        weekday: 'narrow'\n      }),\n      dayOfMonth: getFormatter(culture, {\n        day: '2-digit'\n      }),\n      month: getFormatter(culture, {\n        month: 'short'\n      }),\n      year: getFormatter(culture, {\n        year: 'numeric'\n      }),\n      decade: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'decade'))}`,\n      century: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'century'))}`\n    };\n    Object.keys(formats).forEach(key => {\n      this[key] = (date, format) => format ? normalizeFormat(date, format) : formats[key](date);\n    });\n  }\n\n  toFormattedParts(date, format = {\n    dateStyle: 'short',\n    timeStyle: 'short'\n  }) {\n    return Intl.DateTimeFormat(this.culture, format).formatToParts(date).filter(p => p.type !== 'timeZoneName');\n  }\n\n  parse(value) {\n    const date = new Date(value);\n    return isNaN(+date) ? null : date;\n  }\n\n}\n\n/**\n * A number localization strategy based on `Intl.NumberFormat`.\n */\nclass IntlNumberLocalizer {\n  constructor({\n    culture = undefined\n  } = {}) {\n    var _$toLocaleString$m;\n\n    this.culture = culture;\n    const decimal = 'formatToParts' in Intl.NumberFormat(culture) ? Intl.NumberFormat(culture).formatToParts(1.1)[1].value : ((_$toLocaleString$m = 1.1.toLocaleString(culture).match(/[^\\d]/)) == null ? void 0 : _$toLocaleString$m[0]) || '.';\n    const formatter = Intl.NumberFormat(culture).format;\n\n    this.decimalCharacter = () => decimal;\n\n    this.format = (num, format) => {\n      if (format) {\n        return typeof format === 'function' ? format(num, culture) : num.toLocaleString(culture, format);\n      }\n\n      return formatter(num);\n    };\n  }\n\n  parse(value) {\n    return parseFloat(value.replace(this.decimalCharacter(), '.'));\n  }\n\n}\n\nexport { IntlDateLocalizer as DateLocalizer, IntlNumberLocalizer as NumberLocalizer };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}